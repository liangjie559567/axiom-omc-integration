---
name: subagent-driven-development
description: 在当前会话中执行具有独立任务的实现计划时使用
---

# 子代理驱动开发技能

## 核心原则

**使用专门的子代理并行执行独立任务，最大化开发效率。**

子代理驱动开发不是简单的任务分配，而是：
- ✅ 智能任务分解
- ✅ 并行执行优化
- ✅ 专业化分工
- ✅ 结果验证
- ❌ 不是串行执行
- ❌ 不是手动协调

## 何时使用

### 必须使用的场景

**□ 有明确的实现计划**
- writing-plans 技能已完成
- 任务已分解为独立单元
- 依赖关系已明确

**□ 存在并行机会（≥2个独立任务）**
- 任务之间无共享状态
- 任务之间无顺序依赖
- 可以同时执行

**□ 任务需要专业化处理**
- 不同技术栈（前端/后端/数据库）
- 不同关注点（功能/测试/文档）
- 不同复杂度（简单/中等/复杂）

### 不适用的场景

**□ 任务高度耦合**
- 共享可变状态
- 强顺序依赖
- 需要频繁同步

**□ 简单的单任务**
- 只有一个任务
- 任务很小（<50行）
- 直接执行更快

---

## 子代理类型与选择

### 实现类 Agent

**executor (sonnet)**
- **用途**: 标准代码实现、重构、功能开发
- **适合**: 中等复杂度任务（50-200行）
- **示例**: 实现 API 端点、添加业务逻辑

**deep-executor (opus)**
- **用途**: 复杂的自主目标导向任务
- **适合**: 高复杂度任务（>200行，多文件）
- **示例**: 架构重构、复杂功能实现

**build-fixer (sonnet)**
- **用途**: 修复构建、工具链、类型错误
- **适合**: 编译/类型/lint 错误修复
- **示例**: 修复 TypeScript 类型错误

### 测试类 Agent

**test-engineer (sonnet)**
- **用途**: 测试策略、覆盖率、测试加固
- **适合**: 测试设计和实现
- **示例**: 编写单元测试、集成测试

**qa-tester (sonnet)**
- **用途**: 交互式 CLI/服务运行时验证
- **适合**: 手动测试和验证
- **示例**: 验证功能正确性

### 审查类 Agent

**code-reviewer (opus)**
- **用途**: 全面代码审查
- **适合**: 完成后的质量检查
- **示例**: 审查实现质量

**security-reviewer (sonnet)**
- **用途**: 安全漏洞、信任边界、认证授权
- **适合**: 安全敏感代码
- **示例**: 审查认证逻辑

### 专业类 Agent

**designer (sonnet)**
- **用途**: UX/UI 架构、交互设计
- **适合**: 前端组件、样式工作
- **示例**: 实现 UI 组件

**writer (haiku)**
- **用途**: 文档、迁移说明、用户指南
- **适合**: 文档编写
- **示例**: 编写 API 文档

---

## 执行流程

### 阶段 1: 任务分析

**输入**: writing-plans 的实现计划

**任务**:
1. 读取实现计划
2. 识别独立任务
3. 分析依赖关系
4. 识别并行机会

**输出**: 任务执行策略

```markdown
## 任务执行策略

### 批次 1: 并行执行（无依赖）
- 任务 1.1 → executor
- 任务 1.2 → executor
- 任务 1.3 → test-engineer

### 批次 2: 串行执行（依赖批次 1）
- 任务 2.1 → executor
- 任务 2.2 → build-fixer

### 批次 3: 验证（依赖批次 2）
- 任务 3.1 → qa-tester
- 任务 3.2 → code-reviewer
```

### 阶段 2: 子代理调度

**任务**:
1. 为每个任务选择合适的子代理
2. 准备任务上下文
3. 并行启动子代理
4. 监控执行进度

**调度示例**:
```typescript
// 批次 1: 并行执行
Task(
  subagent_type="oh-my-claudecode:executor",
  model="sonnet",
  prompt="实现用户注册 API\n\n上下文：[实现计划]\n验收：[验收标准]"
)

Task(
  subagent_type="oh-my-claudecode:executor",
  model="sonnet",
  prompt="实现用户登录 API\n\n上下文：[实现计划]\n验收：[验收标准]"
)

Task(
  subagent_type="oh-my-claudecode:test-engineer",
  model="sonnet",
  prompt="编写认证测试\n\n上下文：[实现计划]\n验收：[验收标准]"
)
```

### 阶段 3: 结果收集

**任务**:
1. 等待所有子代理完成
2. 收集执行结果
3. 验证输出质量
4. 识别问题

**输出**: 执行报告

```markdown
## 执行报告

### 批次 1 结果
- ✅ 任务 1.1: 完成，测试通过
- ✅ 任务 1.2: 完成，测试通过
- ❌ 任务 1.3: 失败，需要修复

### 问题清单
1. 任务 1.3 测试失败
   - 原因: [描述]
   - 修复: [方案]
```

### 阶段 4: 问题修复

**任务**:
1. 分析失败原因
2. 调度修复子代理
3. 重新验证
4. 确认完成

**修复示例**:
```typescript
// 修复失败的任务
Task(
  subagent_type="oh-my-claudecode:debugger",
  model="sonnet",
  prompt="分析测试失败原因\n\n错误：[错误信息]\n上下文：[相关代码]"
)

Task(
  subagent_type="oh-my-claudecode:executor",
  model="sonnet",
  prompt="修复测试失败\n\n根因：[分析结果]\n修复方案：[方案]"
)
```

---

## 任务上下文准备

### 必须提供的上下文

**□ 1. 任务目标**
```markdown
## 任务目标
实现用户注册 API，支持邮箱和密码注册。
```

**□ 2. 实现计划**
```markdown
## 实现计划
- 创建 POST /auth/register 端点
- 验证邮箱格式
- 哈希密码（bcrypt）
- 保存到数据库
- 返回用户信息
```

**□ 3. 验收标准**
```markdown
## 验收标准
- [ ] API 端点响应 201
- [ ] 邮箱格式验证
- [ ] 密码已哈希
- [ ] 用户已保存
- [ ] 测试通过
```

**□ 4. 相关文件**
```markdown
## 相关文件
- src/routes/auth.ts: API 路由
- src/services/auth-service.ts: 认证服务
- src/models/user.ts: 用户模型
- tests/auth.test.ts: 测试文件
```

**□ 5. 技术约束**
```markdown
## 技术约束
- 使用 Express.js
- 使用 bcrypt 哈希
- 使用 PostgreSQL
- 遵循项目代码风格
```

---

## 并行执行模式

### 模式 1: 分层并行

**场景**: 不同层级的任务可以并行

```markdown
### 批次 1: 分层并行
- 数据层: executor → 实现 UserRepository
- 服务层: executor → 实现 AuthService
- API 层: executor → 实现 API 路由
- 测试层: test-engineer → 编写测试
```

**优势**: 最大化并行度，快速完成

**风险**: 需要清晰的接口定义，避免集成问题

### 模式 2: 功能并行

**场景**: 不同功能可以并行

```markdown
### 批次 1: 功能并行
- 功能 A: executor → 实现注册功能
- 功能 B: executor → 实现登录功能
- 功能 C: executor → 实现密码重置
```

**优势**: 功能独立，风险低

**风险**: 可能有共享代码，需要协调

### 模式 3: 专业化并行

**场景**: 不同专业领域可以并行

```markdown
### 批次 1: 专业化并行
- 后端: executor → 实现 API
- 前端: designer → 实现 UI
- 测试: test-engineer → 编写测试
- 文档: writer → 编写文档
```

**优势**: 专业化分工，质量高

**风险**: 需要协调接口和集成

---

## 常见问题

### 问题 1: 任务依赖不清晰

**症状**: 子代理执行失败，因为依赖未满足

**原因**: 任务分解时未识别依赖

**解决**:
```markdown
## 依赖分析
- 任务 A 依赖: 无
- 任务 B 依赖: 任务 A 完成
- 任务 C 依赖: 任务 A、B 完成

## 执行顺序
批次 1: 任务 A
批次 2: 任务 B（依赖批次 1）
批次 3: 任务 C（依赖批次 2）
```

### 问题 2: 上下文不足

**症状**: 子代理请求更多信息

**原因**: 任务上下文准备不充分

**解决**:
```markdown
## 完整上下文
- 任务目标: [详细描述]
- 实现计划: [步骤]
- 验收标准: [标准]
- 相关文件: [文件列表]
- 技术约束: [约束]
- 示例代码: [参考实现]
```

### 问题 3: 结果不一致

**症状**: 不同子代理的输出风格不一致

**原因**: 缺少统一的代码风格指南

**解决**:
```markdown
## 代码风格要求
- 遵循项目 ESLint 配置
- 使用 Prettier 格式化
- 遵循命名约定
- 遵循文件组织结构
```

---

## 与其他技能的配合

### 工作流程
```
writing-plans (实现规划)
    ↓
subagent-driven-development (子代理驱动开发) ← 当前技能
    ↓
verification-before-completion (验证完成)
```

### 配合原则
1. **输入来源**: writing-plans 的实现计划
2. **执行方式**: 并行调度子代理
3. **输出验证**: verification-before-completion 验证结果
4. **问题修复**: systematic-debugging 分析问题
5. **完成开发**: finishing-a-development-branch 完成分支

---

## 实际案例

### 案例 1: 用户认证功能

**实现计划**: 3 个批次，9 个任务

**执行策略**:
```markdown
## 批次 1: 数据层（并行）
- Task 1: executor → 创建 users 表
- Task 2: executor → 实现 UserRepository
- Task 3: test-engineer → 编写 Repository 测试

## 批次 2: 服务层（并行，依赖批次 1）
- Task 4: executor → 实现 AuthService.register
- Task 5: executor → 实现 AuthService.login
- Task 6: executor → 实现 TokenService
- Task 7: test-engineer → 编写服务层测试

## 批次 3: API 层（并行，依赖批次 2）
- Task 8: executor → 实现 API 路由
- Task 9: test-engineer → 编写 API 测试
```

**执行结果**:
```markdown
## 执行报告
- 批次 1: 3 个任务并行，2 分钟完成
- 批次 2: 4 个任务并行，3 分钟完成
- 批次 3: 2 个任务并行，2 分钟完成
- 总时间: 7 分钟（串行需要 18 分钟）
- 效率提升: 61%
```

---

## 记住

**子代理驱动开发原则：**

1. **并行优先** - 最大化并行执行
2. **专业化分工** - 选择合适的子代理
3. **上下文充分** - 提供完整的任务上下文
4. **依赖明确** - 清晰的任务依赖关系
5. **结果验证** - 验证所有子代理输出

**不要：**
- ❌ 串行执行可并行的任务
- ❌ 上下文不足就启动子代理
- ❌ 忽略任务依赖关系
- ❌ 跳过结果验证

**要：**
- ✅ 识别并行机会
- ✅ 准备完整上下文
- ✅ 明确依赖关系
- ✅ 验证执行结果

**现在开始子代理驱动开发。**
