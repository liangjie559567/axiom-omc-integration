---
name: brainstorming
description: 在任何创意工作前使用 - 创建功能、构建组件、添加功能或修改行为前，必须先探索用户意图、需求和设计
---

# 需求澄清技能

## 铁律

**在编写任何实现代码之前，必须先完成需求澄清。**

```
NO IMPLEMENTATION WITHOUT REQUIREMENT CLARIFICATION FIRST
```

## 核心原则

编码不是猜测游戏。这是一个系统化的需求理解过程：

- ✅ 先理解需求
- ✅ 识别假设
- ✅ 定义验收标准
- ✅ 然后才实现
- ❌ 不要基于假设编码

## 强制问题清单（HARD-GATE）

### 在开始实现前，必须回答以下问题：

#### 1. 目标理解
```markdown
□ 用户想要解决什么问题？
□ 为什么需要这个功能？
□ 成功的标准是什么？
□ 有哪些约束条件？
```

**无法回答任何一项 → 停止，向用户提问。**

#### 2. 范围界定
```markdown
□ 这个功能包含哪些部分？
□ 哪些是必需的？哪些是可选的？
□ 有哪些明确不包含的内容？
□ 边界在哪里？
```

**范围模糊 → 停止，与用户确认边界。**

#### 3. 假设识别
```markdown
□ 我做了哪些假设？
□ 这些假设是否合理？
□ 哪些假设需要验证？
□ 如果假设错误会怎样？
```

**存在未验证的关键假设 → 停止，向用户确认。**

#### 4. 验收标准
```markdown
□ 如何验证功能正确？
□ 有哪些测试场景？
□ 边界条件是什么？
□ 错误情况如何处理？
```

**验收标准不清晰 → 停止，定义清晰的标准。**

---

## 需求澄清流程

### 阶段 1: 初步理解

**快速阅读需求，识别关键词：**

```markdown
## 初步理解
- **核心需求**: [一句话描述]
- **关键词**: [列出关键术语]
- **初步疑问**: [列出不清楚的地方]
```

### 阶段 2: 深度提问

**针对疑问进行系统化提问：**

#### 功能性问题
```markdown
- 这个功能的输入是什么？
- 期望的输出是什么？
- 有哪些处理步骤？
- 需要与哪些系统交互？
```

#### 非功能性问题
```markdown
- 性能要求是什么？
- 安全性要求是什么？
- 可用性要求是什么？
- 可维护性要求是什么？
```

#### 约束条件
```markdown
- 技术栈限制？
- 时间限制？
- 资源限制？
- 兼容性要求？
```

### 阶段 3: 假设验证

**列出所有假设并逐一验证：**

```markdown
## 假设清单
1. **假设**: [描述假设]
   - **依据**: [为什么这样假设]
   - **风险**: [如果错误会怎样]
   - **验证方式**: [如何确认]
   - **状态**: [已验证/待验证/已否定]

2. **假设**: ...
```

**验证方式：**
- 向用户提问
- 查阅文档
- 检查现有代码
- 运行实验

### 阶段 4: 验收标准定义

**定义清晰、可测试的验收标准：**

```markdown
## 验收标准

### 功能验收
- [ ] 场景 1: [描述] → [期望结果]
- [ ] 场景 2: [描述] → [期望结果]
- [ ] 场景 3: [描述] → [期望结果]

### 边界条件
- [ ] 空输入 → [期望行为]
- [ ] 无效输入 → [期望行为]
- [ ] 极限值 → [期望行为]

### 错误处理
- [ ] 错误类型 1 → [如何处理]
- [ ] 错误类型 2 → [如何处理]

### 性能标准
- [ ] 响应时间 < [具体数值]
- [ ] 内存占用 < [具体数值]
- [ ] 并发支持 >= [具体数值]
```

---

## 常见需求陷阱

### 陷阱 1: 模糊的动词

**❌ 错误示例：**
```
"优化系统性能"
"改进用户体验"
"增强安全性"
```

**问题：** 没有具体目标，无法验证。

**✅ 正确做法：**
```markdown
## 澄清问题
- 优化哪个部分的性能？
- 当前性能指标是多少？
- 目标性能指标是多少？
- 如何测量性能？
```

---

### 陷阱 2: 隐含的假设

**❌ 错误示例：**
```
"添加用户登录功能"
```

**隐含假设：**
- 使用用户名/密码登录？
- 支持第三方登录？
- 需要记住登录状态？
- 密码如何存储？
- 会话如何管理？

**✅ 正确做法：**
```markdown
## 假设验证
- [ ] 登录方式：用户名/密码 ✓
- [ ] 第三方登录：不需要 ✓
- [ ] 记住登录：需要，7天有效期 ✓
- [ ] 密码存储：bcrypt 哈希 ✓
- [ ] 会话管理：JWT token ✓
```

---

### 陷阱 3: 缺失的边界

**❌ 错误示例：**
```
"实现文件上传功能"
```

**缺失的边界：**
- 支持哪些文件类型？
- 文件大小限制？
- 并发上传数量？
- 上传失败如何处理？
- 存储在哪里？

**✅ 正确做法：**
```markdown
## 边界定义
- **文件类型**: 图片（jpg, png, gif）和文档（pdf, docx）
- **大小限制**: 单文件 10MB，总计 100MB
- **并发限制**: 最多 3 个文件同时上传
- **失败处理**: 显示错误消息，允许重试
- **存储位置**: AWS S3，按日期分目录
```

---

### 陷阱 4: 不可测试的标准

**❌ 错误示例：**
```
"系统应该快速响应"
"界面应该美观"
"代码应该易于维护"
```

**问题：** 主观、无法量化、无法验证。

**✅ 正确做法：**
```markdown
## 可测试标准
- **响应速度**: API 响应时间 < 200ms (P95)
- **界面美观**: 遵循设计系统规范，通过设计审查
- **代码维护**: 圈复杂度 < 10，测试覆盖率 > 80%
```

---

## 需求文档模板

```markdown
# 需求文档：[功能名称]

## 1. 目标
**问题陈述**: [描述要解决的问题]
**目标用户**: [谁会使用这个功能]
**成功标准**: [如何定义成功]

## 2. 功能范围
**包含**:
- [功能点 1]
- [功能点 2]
- [功能点 3]

**不包含**:
- [明确排除的内容 1]
- [明确排除的内容 2]

## 3. 用户故事
作为 [角色]，我想要 [功能]，以便 [目的]。

**验收标准**:
- [ ] 场景 1: [描述] → [结果]
- [ ] 场景 2: [描述] → [结果]

## 4. 技术约束
- **技术栈**: [列出使用的技术]
- **性能要求**: [具体指标]
- **安全要求**: [具体要求]
- **兼容性**: [支持的平台/浏览器]

## 5. 假设与依赖
**假设**:
- [假设 1] - [验证状态]
- [假设 2] - [验证状态]

**依赖**:
- [依赖 1] - [状态]
- [依赖 2] - [状态]

## 6. 风险与缓解
| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| [风险 1] | 高/中/低 | 高/中/低 | [措施] |
| [风险 2] | 高/中/低 | 高/中/低 | [措施] |

## 7. 验收测试
```typescript
describe('功能名称', () => {
  test('场景 1', () => {
    // 测试代码
  });

  test('场景 2', () => {
    // 测试代码
  });
});
```
```

---

## 与其他技能的配合

### 工作流程
```
brainstorming (需求澄清)
    ↓
writing-plans (实现规划)
    ↓
test-driven-development (测试驱动开发)
    ↓
executing-plans (执行实现)
    ↓
systematic-debugging (系统化调试)
    ↓
verification-before-completion (验证完成)
```

### 配合原则
1. **brainstorming 先行**: 在任何实现前必须先澄清需求
2. **输出作为输入**: brainstorming 的输出是 writing-plans 的输入
3. **验收标准驱动**: 定义的验收标准直接转化为测试用例
4. **假设追踪**: 识别的假设在实现过程中持续验证

---

## 实际案例

### 案例 1: 模糊需求

**原始需求**: "添加搜索功能"

**澄清过程**:
```markdown
## 问题清单
1. 搜索什么内容？
   → 用户、文章、标签
2. 搜索范围？
   → 全站搜索
3. 搜索方式？
   → 关键词匹配，支持模糊搜索
4. 结果排序？
   → 按相关度排序
5. 性能要求？
   → 响应时间 < 500ms
6. 分页？
   → 每页 20 条，支持无限滚动
```

**澄清后的需求**:
```markdown
# 全站搜索功能

## 功能范围
- 搜索内容：用户、文章、标签
- 搜索方式：关键词模糊匹配
- 结果排序：按相关度（TF-IDF）
- 分页：每页 20 条，无限滚动

## 验收标准
- [ ] 输入关键词，返回匹配结果
- [ ] 结果按相关度排序
- [ ] 响应时间 < 500ms (P95)
- [ ] 支持无限滚动加载
- [ ] 空结果显示友好提示
```

---

### 案例 2: 隐含假设

**原始需求**: "实现用户权限管理"

**假设识别**:
```markdown
## 假设清单
1. **假设**: 使用 RBAC (基于角色的访问控制)
   - **依据**: 常见的权限模型
   - **风险**: 可能需要更细粒度的控制
   - **验证**: 询问用户是否需要资源级权限
   - **结果**: ✓ 确认使用 RBAC

2. **假设**: 角色可以动态创建
   - **依据**: 灵活性需求
   - **风险**: 增加复杂度
   - **验证**: 询问用户是否需要动态角色
   - **结果**: ✗ 只需要预定义角色

3. **假设**: 权限变更立即生效
   - **依据**: 安全性考虑
   - **风险**: 可能影响性能
   - **验证**: 询问用户对实时性的要求
   - **结果**: ✓ 需要立即生效
```

**澄清后的需求**:
```markdown
# 用户权限管理

## 权限模型
- 使用 RBAC 模型
- 预定义角色：管理员、编辑、查看者
- 权限变更立即生效

## 功能范围
- 分配用户角色
- 检查用户权限
- 权限变更审计日志

## 不包含
- 动态创建角色
- 资源级细粒度权限
- 权限继承
```

---

## 记住

**需求澄清原则：**

1. **永远不要假设** - 所有不确定的地方都要提问
2. **具体化** - 将模糊的需求转化为具体的标准
3. **可测试** - 所有验收标准都必须可测试
4. **边界清晰** - 明确包含什么、不包含什么
5. **假设透明** - 列出所有假设并验证

**不要：**
- ❌ 基于假设开始编码
- ❌ 接受模糊的需求
- ❌ 跳过验收标准定义
- ❌ 忽略边界条件

**要：**
- ✅ 系统化提问
- ✅ 验证所有假设
- ✅ 定义清晰的验收标准
- ✅ 记录需求文档

**现在开始需求澄清。**

---

## 需求澄清完成后的工作流引导

### 自动工作流推荐

当需求澄清完成后，必须根据任务复杂度智能推荐合适的工作流：

#### 复杂度评估标准

**简单任务**（推荐：直接实现）：
- 单文件修改
- <50 行代码
- 无复杂依赖
- 明确的实现路径

**中等任务**（推荐：writing-plans → executing-plans）：
- 2-5 个文件
- 50-200 行代码
- 少量依赖
- 需要规划但不复杂

**复杂任务**（推荐：team/autopilot/ralph）：
- >5 个文件
- >200 行代码
- 复杂依赖和集成
- 需要多步骤协调

#### 工作流推荐模板

```markdown
## 📋 需求澄清完成

✅ 已完成需求澄清，以下是总结：

**核心需求**: [一句话描述]
**功能范围**: [列出主要功能点]
**验收标准**: [列出关键验收条件]
**约束条件**: [列出关键约束]

---

## 🚀 推荐工作流

根据任务复杂度分析，推荐使用：**[工作流名称]**

**理由**：
- [复杂度评估]
- [为什么选择这个工作流]
- [预期收益]

**下一步操作**：

### 选项 A：自动执行（推荐）
我可以立即使用推荐的工作流开始执行。

**命令**：直接回复 "开始" 或 "执行"

### 选项 B：选择其他工作流
如果你想使用其他工作流，可以选择：

1. **autopilot** - 全自动执行，从想法到代码
2. **ralph** - 持久化循环，不停止直到完成
3. **team** - 多代理协调，适合复杂任务
4. **pipeline** - 顺序链式执行
5. **ultrawork** - 最大并行度执行
6. **writing-plans** - 先规划再执行
7. **直接实现** - 简单任务直接编码

**命令**：回复工作流名称，如 "team" 或 "autopilot"

### 选项 C：手动规划
如果你想先看详细规划再决定。

**命令**：回复 "先规划" 或 "看计划"

---

**请选择：开始 / [工作流名称] / 先规划**
```

### 工作流选择决策树

```
任务复杂度？
├─ 简单（<50行，单文件）
│  └─ 推荐：直接实现
│     └─ 提示："我将直接开始实现，预计 5-10 分钟完成"
│
├─ 中等（50-200行，2-5文件）
│  └─ 推荐：writing-plans → executing-plans
│     └─ 提示："我将先制定详细计划，然后执行"
│
└─ 复杂（>200行，>5文件）
   ├─ 需要持久化？
   │  └─ 是 → ralph（包含 ultrawork）
   │     └─ 提示："使用 ralph 持久化循环，确保完成"
   │
   ├─ 需要多代理协调？
   │  └─ 是 → team
   │     └─ 提示："使用 team 多代理协调执行"
   │
   ├─ 需要最大并行？
   │  └─ 是 → ultrawork
   │     └─ 提示："使用 ultrawork 最大化并行执行"
   │
   └─ 默认 → autopilot
      └─ 提示："使用 autopilot 全自动执行"
```

### 实施规则

1. **必须推荐**：需求澄清完成后，必须给出工作流推荐
2. **必须说明理由**：解释为什么推荐这个工作流
3. **提供选项**：给用户选择的自由
4. **默认自动**：如果用户回复"开始"，使用推荐的工作流
5. **记录决策**：在 operations-log.md 中记录工作流选择

### 自动执行示例

当用户回复"开始"或"执行"时：

```markdown
✅ 收到确认，开始使用 [工作流名称] 执行...

[调用相应的技能或工作流]
```

---

## 用户回复处理指令

### 当用户回复时，必须按以下规则处理：

#### 规则 1: 识别回复类型

**自动执行回复**（触发推荐工作流）：
- "开始"
- "执行"
- "go"
- "start"

**工作流选择回复**（触发指定工作流）：
- "autopilot"
- "ralph"
- "team"
- "pipeline"
- "ultrawork"
- "writing-plans"
- "test-driven-development"
- "直接实现"

**规划回复**（先规划再执行）：
- "先规划"
- "看计划"
- "plan"

#### 规则 2: 执行对应操作

**当用户回复"开始"或"执行"时**：

1. 记录决策到 operations-log.md：
```markdown
## 工作流选择决策
时间：[当前时间]
推荐工作流：[工作流名称]
用户选择：自动执行（接受推荐）
理由：[复杂度评估和推荐理由]
```

2. 根据推荐的工作流类型执行：
   - **简单任务（直接实现）**：直接开始编码
   - **中等任务（writing-plans）**：调用 `/axiom-omc:writing-plans`
   - **复杂任务**：调用相应技能（autopilot/ralph/team等）

3. 输出确认消息：
```markdown
✅ 收到确认，开始使用 [工作流名称] 执行...

[立即开始执行]
```

**当用户回复工作流名称时**：

1. 记录决策：
```markdown
## 工作流选择决策
时间：[当前时间]
推荐工作流：[原推荐]
用户选择：[用户指定的工作流]
理由：用户主动选择
```

2. 调用指定的工作流：
   - 使用 Skill 工具调用：`/axiom-omc:[工作流名称]`
   - 传递需求澄清的结果作为上下文

3. 输出确认消息：
```markdown
✅ 收到，使用 [用户选择的工作流] 执行...

[调用工作流]
```

**当用户回复"先规划"时**：

1. 记录决策：
```markdown
## 工作流选择决策
时间：[当前时间]
推荐工作流：[原推荐]
用户选择：先规划
理由：用户希望先看详细计划
```

2. 调用 writing-plans 技能：
```markdown
✅ 收到，我将先制定详细计划...

[调用 /axiom-omc:writing-plans]
```

#### 规则 3: 工作流调用示例

**调用 writing-plans**：
```
使用 Skill 工具调用 axiom-omc:writing-plans，传递需求摘要
```

**调用 autopilot**：
```
使用 Skill 工具调用 axiom-omc:autopilot，传递需求摘要
```

**直接实现**：
```
不调用其他技能，直接开始编码实现
```

---

**现在开始需求澄清。**
