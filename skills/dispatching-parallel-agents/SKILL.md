---
name: dispatching-parallel-agents
description: 在有 2 个或以上独立任务时使用，通过并行调度多个代理最大化执行效率
---

# 并行代理调度技能

## 铁律

**在有 2 个或以上独立任务时，必须使用并行调度而非串行执行。**

```
NO SERIAL EXECUTION WHEN PARALLEL IS POSSIBLE
```

## 核心原则

并行调度不是可选优化，而是：
- ✅ 最大化效率
- ✅ 独立性验证
- ✅ 智能调度
- ✅ 结果整合
- ✅ 错误隔离
- ❌ 不是串行执行
- ❌ 不是手动协调

## 何时使用

### 必须使用的场景

**□ 存在 2+ 个独立任务**
- 任务之间无共享状态
- 任务之间无顺序依赖
- 任务可以同时执行

**□ 任务结果可独立验证**
- 每个任务有明确的验收标准
- 任务失败不影响其他任务
- 结果可以独立收集

**□ 任务执行时间 >30 秒**
- 并行收益大于调度开销
- 总执行时间可显著缩短

### 不适用的场景

**□ 任务高度耦合**
- 共享可变状态
- 强顺序依赖
- 需要频繁同步

**□ 单个任务**
- 只有一个任务
- 无并行机会

**□ 任务很小（<30 秒）**
- 调度开销大于收益
- 直接执行更快

---

## 调度流程

### 阶段 1: 独立性分析

**目标**: 识别可并行的任务

**任务**:
1. 列出所有待执行任务
2. 分析任务间依赖关系
3. 识别共享状态
4. 确定并行批次

**独立性检查清单**:
```markdown
## 独立性验证

### 任务 A vs 任务 B
- [ ] 无共享可变状态
- [ ] 无顺序依赖（A 不依赖 B，B 不依赖 A）
- [ ] 无资源竞争（文件、数据库、API）
- [ ] 结果可独立验证

### 结论
- ✅ 可并行：任务 A 和 B 完全独立
- ❌ 不可并行：存在依赖或共享状态
```

**输出**: 并行批次计划

```markdown
## 并行批次计划

### 批次 1（并行）
- 任务 A：无依赖
- 任务 B：无依赖
- 任务 C：无依赖

### 批次 2（并行，依赖批次 1）
- 任务 D：依赖任务 A
- 任务 E：依赖任务 B

### 批次 3（串行，依赖批次 2）
- 任务 F：依赖任务 D 和 E
```

### 阶段 2: 代理选择

**目标**: 为每个任务选择合适的代理类型

**代理选择矩阵**:

| 任务类型 | 推荐代理 | 模型 | 理由 |
|---------|---------|------|------|
| 代码实现 | executor | sonnet | 标准实现任务 |
| 复杂实现 | deep-executor | opus | 自主目标导向 |
| 测试编写 | test-engineer | sonnet | 测试策略专家 |
| 代码审查 | code-reviewer | opus | 全面质量检查 |
| 安全审查 | security-reviewer | sonnet | 安全漏洞检测 |
| 文档编写 | writer | haiku | 快速文档生成 |
| UI 设计 | designer | sonnet | UX/UI 专家 |
| 构建修复 | build-fixer | sonnet | 工具链专家 |
| 问题调试 | debugger | sonnet | 根因分析 |

**选择原则**:
1. **任务复杂度** → 选择合适的模型（haiku/sonnet/opus）
2. **任务类型** → 选择专业化代理
3. **任务优先级** → 高优先级使用更强模型

### 阶段 3: 并行启动

**目标**: 同时启动所有独立任务

**启动模板**:
```typescript
// 批次 1: 并行启动 3 个独立任务
Task(
  subagent_type="oh-my-claudecode:executor",
  model="sonnet",
  prompt="任务 A：实现用户注册\n\n上下文：[详细上下文]\n验收：[验收标准]"
)

Task(
  subagent_type="oh-my-claudecode:executor",
  model="sonnet",
  prompt="任务 B：实现用户登录\n\n上下文：[详细上下文]\n验收：[验收标准]"
)

Task(
  subagent_type="oh-my-claudecode:test-engineer",
  model="sonnet",
  prompt="任务 C：编写认证测试\n\n上下文：[详细上下文]\n验收：[验收标准]"
)
```

**关键要点**:
- 所有任务在同一个响应中启动
- 每个任务有完整的上下文
- 每个任务有明确的验收标准

### 阶段 4: 进度监控

**目标**: 跟踪每个代理的执行状态

**监控清单**:
```markdown
## 执行状态

### 批次 1
- 任务 A (executor): 🔄 执行中
- 任务 B (executor): 🔄 执行中
- 任务 C (test-engineer): 🔄 执行中

### 预计完成时间
- 批次 1: 3-5 分钟
```

**状态标识**:
- 🔄 执行中
- ✅ 已完成
- ❌ 失败
- ⏸️ 等待依赖

### 阶段 5: 结果收集

**目标**: 收集所有代理的输出

**收集清单**:
```markdown
## 执行结果

### 批次 1 结果
- ✅ 任务 A: 完成
  - 输出: src/auth/register.ts
  - 验证: 测试通过

- ✅ 任务 B: 完成
  - 输出: src/auth/login.ts
  - 验证: 测试通过

- ❌ 任务 C: 失败
  - 错误: 测试框架配置错误
  - 需要: 修复配置后重试
```

### 阶段 6: 结果整合

**目标**: 整合并验证最终结果

**整合步骤**:
1. 验证所有任务完成
2. 检查输出一致性
3. 运行集成测试
4. 确认无冲突

**整合验证**:
```markdown
## 整合验证

### 一致性检查
- [ ] 代码风格一致
- [ ] 命名约定一致
- [ ] 接口契约一致
- [ ] 测试覆盖完整

### 集成测试
```bash
npm test
# 验证：所有测试通过
```

### 冲突检查
- [ ] 无文件冲突
- [ ] 无逻辑冲突
- [ ] 无依赖冲突
```

---

## 错误处理

### 场景 1: 单个代理失败

**症状**: 一个代理失败，其他代理成功

**处理**:
```markdown
## 失败处理

### 失败任务
- 任务 C (test-engineer): 测试框架配置错误

### 影响分析
- 不影响任务 A 和 B
- 可以独立修复

### 修复方案
1. 分析失败原因
2. 调度修复代理
3. 重新执行任务 C
4. 验证修复结果
```

**修复示例**:
```typescript
// 调度 debugger 分析失败原因
Task(
  subagent_type="oh-my-claudecode:debugger",
  model="sonnet",
  prompt="分析任务 C 失败原因\n\n错误：[错误信息]\n上下文：[相关代码]"
)

// 调度 executor 修复问题
Task(
  subagent_type="oh-my-claudecode:executor",
  model="sonnet",
  prompt="修复测试框架配置\n\n根因：[分析结果]\n修复方案：[方案]"
)
```

### 场景 2: 多个代理失败

**症状**: 多个代理失败，可能有共同原因

**处理**:
```markdown
## 批量失败处理

### 失败模式分析
- 任务 A: 依赖缺失
- 任务 B: 依赖缺失
- 任务 C: 依赖缺失

### 共同原因
- 环境配置问题
- 依赖未安装

### 修复方案
1. 修复共同原因（安装依赖）
2. 重新执行所有失败任务
3. 验证修复结果
```

### 场景 3: 依赖任务失败

**症状**: 被依赖的任务失败，后续任务无法执行

**处理**:
```markdown
## 依赖失败处理

### 失败任务
- 任务 A: 失败（被任务 D 依赖）

### 影响分析
- 任务 D 无法执行（依赖任务 A）
- 任务 B、C 不受影响（无依赖关系）

### 处理策略
1. 停止任务 D 的执行
2. 修复任务 A
3. 重新执行任务 A
4. 验证任务 A 完成
5. 启动任务 D
```

---

## 并行模式

### 模式 1: 完全并行

**场景**: 所有任务完全独立

```markdown
### 批次 1: 完全并行
- 任务 A: 无依赖
- 任务 B: 无依赖
- 任务 C: 无依赖
- 任务 D: 无依赖

### 执行时间
- 串行: 4 × 5 分钟 = 20 分钟
- 并行: max(5, 5, 5, 5) = 5 分钟
- 效率提升: 75%
```

### 模式 2: 分批并行

**场景**: 任务有依赖关系，分批执行

```markdown
### 批次 1: 并行（无依赖）
- 任务 A: 无依赖
- 任务 B: 无依赖

### 批次 2: 并行（依赖批次 1）
- 任务 C: 依赖任务 A
- 任务 D: 依赖任务 B

### 执行时间
- 串行: 4 × 5 分钟 = 20 分钟
- 并行: 2 × 5 分钟 = 10 分钟
- 效率提升: 50%
```

### 模式 3: 混合并行

**场景**: 部分任务并行，部分任务串行

```markdown
### 批次 1: 并行
- 任务 A: 无依赖
- 任务 B: 无依赖

### 批次 2: 串行（依赖批次 1 的所有任务）
- 任务 C: 依赖任务 A 和 B

### 执行时间
- 串行: 3 × 5 分钟 = 15 分钟
- 并行: 5 + 5 = 10 分钟
- 效率提升: 33%
```

---

## 常见问题

### 问题 1: 误判独立性

**症状**: 并行执行后出现冲突或错误

**原因**: 任务实际上有隐藏依赖

**解决**:
```markdown
## 依赖分析

### 重新检查
- 共享状态: 任务 A 和 B 都修改同一个文件
- 顺序依赖: 任务 B 需要任务 A 的输出
- 资源竞争: 任务 A 和 B 都访问同一个数据库

### 修正方案
- 将任务 A 和 B 改为串行执行
- 或者重新设计任务，消除依赖
```

### 问题 2: 代理选择不当

**症状**: 任务执行质量不佳或失败

**原因**: 选择了不合适的代理类型

**解决**:
```markdown
## 代理重新选择

### 原选择
- 任务: 复杂架构重构
- 代理: executor (sonnet)
- 问题: 能力不足，无法完成

### 修正选择
- 任务: 复杂架构重构
- 代理: deep-executor (opus)
- 理由: 需要自主目标导向能力
```

### 问题 3: 上下文不足

**症状**: 代理请求更多信息或输出不符合预期

**原因**: 任务上下文准备不充分

**解决**:
```markdown
## 完整上下文模板

### 任务目标
[明确的目标描述]

### 实现计划
[详细的实现步骤]

### 验收标准
[可验证的验收条件]

### 相关文件
[文件路径列表]

### 技术约束
[技术栈、框架、规范]

### 示例代码
[参考实现或类似代码]
```

---

## 与其他技能的配合

### 工作流程
```
writing-plans (实现规划)
    ↓
dispatching-parallel-agents (并行代理调度) ← 当前技能
    ↓
verification-before-completion (验证完成)
```

### 配合原则
1. **输入来源**: writing-plans 的任务分解
2. **独立性验证**: 确认任务可并行
3. **代理选择**: 根据任务类型选择代理
4. **结果整合**: 整合并验证最终结果
5. **输出验证**: verification-before-completion 验证

---

## 实际案例

### 案例 1: 用户认证功能

**任务分解**: 6 个任务

**独立性分析**:
```markdown
## 独立性矩阵

|   | A | B | C | D | E | F |
|---|---|---|---|---|---|---|
| A | - | ✅ | ✅ | ❌ | ✅ | ❌ |
| B | ✅ | - | ✅ | ✅ | ❌ | ❌ |
| C | ✅ | ✅ | - | ✅ | ✅ | ❌ |
| D | ❌ | ✅ | ✅ | - | ✅ | ❌ |
| E | ✅ | ❌ | ✅ | ✅ | - | ❌ |
| F | ❌ | ❌ | ❌ | ❌ | ❌ | - |

✅ = 可并行
❌ = 有依赖
```

**并行批次**:
```markdown
### 批次 1: 并行（5 个任务）
- 任务 A: 实现 UserRepository (executor)
- 任务 B: 实现 AuthService (executor)
- 任务 C: 实现 TokenService (executor)
- 任务 D: 实现 API 路由 (executor)
- 任务 E: 编写测试 (test-engineer)

### 批次 2: 串行（1 个任务）
- 任务 F: 集成测试 (qa-tester)
  - 依赖: 所有批次 1 任务完成
```

**执行结果**:
```markdown
## 执行报告

### 批次 1 结果
- ✅ 任务 A: 完成（3 分钟）
- ✅ 任务 B: 完成（4 分钟）
- ✅ 任务 C: 完成（2 分钟）
- ✅ 任务 D: 完成（3 分钟）
- ✅ 任务 E: 完成（5 分钟）

### 批次 2 结果
- ✅ 任务 F: 完成（2 分钟）

### 总时间
- 串行: 3+4+2+3+5+2 = 19 分钟
- 并行: max(3,4,2,3,5) + 2 = 7 分钟
- 效率提升: 63%
```

---

## 记住

**并行代理调度原则：**

1. **独立性优先** - 只并行真正独立的任务
2. **最大化并行度** - 识别所有可并行机会
3. **智能调度** - 选择合适的代理类型
4. **结果整合** - 确保并行结果一致性
5. **错误隔离** - 单个失败不影响其他任务

**不要：**
- ❌ 串行执行可并行的任务
- ❌ 误判任务独立性
- ❌ 选择不合适的代理
- ❌ 忽略结果整合

**要：**
- ✅ 验证任务独立性
- ✅ 选择合适的代理
- ✅ 提供完整上下文
- ✅ 整合并验证结果

**现在开始并行代理调度。**
